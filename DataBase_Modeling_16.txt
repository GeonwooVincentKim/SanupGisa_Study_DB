1. 순환관계 처리 SQL (JOIN 과 비교)
- 1. 순전개시는 P_ID Index 필요
  = 1. 효율적인 Index 사용을 위해 NULL 보다 SPACE 가 유리
  = 2. LPAD
     -> 1. LEVEL 에 따라 Left 부터 Padding 이 일어남
     -> 2. 책의 목차 구조처럼 Data 들을 보여줌

- 2. 역전개시는 ID Index 필요

2. M:M 계층 구조와 코드 부여 방법
- 1. 동일한 개체가 여러 개의 Code 를 가지게 됨
  = 1. N 계층이 될 때에는 현재 실행되고 있는 Data 를 잠시 Save 한 후, 다른 Data 를 실행해야 함
  = 2. Program 의 Depth (깊이) 가 몇 단계로 구성되어 있는지 잘 모를경우, Logic 을 만들어서 구축 (C언어 or COBOL)
  = 3. SQL 을 사용할 경우, Data 를 잠시 Save 및 다른 Data 를 실행할 필요 없이 CONNECT BY START WITH 로 스스로 모든 Data 들을 보여줌

- 2. 같은 개체이지만 구분이 불가능
- 3. Recursive 구조의 Data 를 만들 때, Key Label 를 Data Source 에서 빼면 안됨
- 4. 반드시 넣는 방법으로 관리하는 것이 좋음

3. 순환관계 처리 SQL (형태별)
- 1. 소 그룹별 전행 (순환) 전개
  = 1. 구조는 같지만, 전혀 상관관계가 없는 관계
  = 2. Group 내부적으로 Recursive 가 만들어져 있는 (여러 Set 가 만들어져 있는) Case
  = 3. Example
     -> 1. EXPLAIN PLAIN SEARCH_STATE.ID = 'A1'
     -> 2. EXPLAIN PLAIN SEARCH_STATE.ID = 'A2'
     -> 3. 두 개의 Group 은 서로 아무런 상관관계가 존재하지 않음
  
  = 4. Query
     -> 1. SELECT LPAD ('', 2 * LEVEL) || COLI...
            FROM BOM
            CONNECT BY PRIOR ID = P_ID
              AND I_ID = 1
            START WITH P_ID = 'A'
              AND I_ID = 1

    -> 2. WHERE CLAUSE 는 Check 기능이기 때문에 `AND T_ID = 1` 모두 Under-Cut 발생
        => `GET 1` 을 천만배로 설정 할 수 없음

- 2. 전체 그룹 (집합) 순환 전개
  = 1. 전체 집합끼리 전체가 하나의 Recursive 로 묶여져 있는 것
