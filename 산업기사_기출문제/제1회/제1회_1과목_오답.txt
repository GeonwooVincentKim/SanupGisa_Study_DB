3. CRUD 분석
- 1. DB 분석 시 Process, Table 을 행열로 구분하여 표 생성
- 2. CRUD, 서로 간에 발생하는 작업 및 변화를 표시하여 분석하는 것
- 3. 특정 테이블에 집중되는 트랜잭션의 양을 측정가능
- 4. DB 용량 산정 및 구조 최적화 도움이 되는 분석 방법


4. 출력한 결과, (결과 실수일 경우, 소수점 이하는 생략하여 정수로만 표기)
- 1. 81
- 2. 수리2


10. SNMP
- 1. TCP/IP 네트워크 관리 프로토콜
- 2. 라우터, 허브
- 3. 네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 전송, 표준 통신 규약


12. 네트워크 슬라이싱
- 1. 5G 핵심기술 중 하나
- 2. 물리적 코어 네트워크 인프라
- 3. 다수 가상 네트워크
- 4. 고객 맞춤형 서비스 제공

-> 1. 메시 네트워크 
   = 1. 차세대 이동통신
   = 2. 홈네트워킹
   = 3. 공공 안전 등 특수 목적
   = 4. 대규모 디바이스 네트워크 생성

-> 2. 애드 훅 네트워크 - 재난 상황

-> 3. 네트워크 슬라이싱 
  = 1. 5G 핵심기술 중 하나
  = 2. 물리적 코어 네트워크 인프라
  = 3. 다수 가상 네트워크
  = 4. 고객 맞춤형 서비스 제공


13. 데이터베이스의 목표 중 하나인 논리적 독립성에 대해 간략히 서술
- 데이터베이스 논리적 구조가 변경되더라도 응용프로그램은 변하지 않는다.


14. 

void func(char* str) {
  int i = 1, cnt = 0;
  while (cnt++ < 5) {
    if (i > 7) i = i - 4;
    printf("%c", *(str + i));
    i = i + 3;
  }
}

main () {
  char str[] = "ABCDEFGH";
  func(str);
}

- 1. str[] = "ABCDEFGH";
- 2. cnt = 0, cnt = 1 < 5 (true)
- 3. i = 1, *(str + 1) -> B
- 4. i = 1 + 3 -> 4

- 5. cnt = 1, cnt = 2 < 5 (true)
- 6. i = 4, *(str + 4) -> E
- 7. i = 4 + 3 -> 7

- 8. cnt = 2, cnt = 3 < 5 (true)
- 9. i = 7, *(str + 7) -> H
- 10. i = 7 + 3 -> 10

- 11. cnt = 3, cnt = 4 < 5 (true)
- 12. i = 10, (i > 7) i = 10 - 4 -> 6;
- 13. i = 6, *(str + 6) -> G
- 14. i = 6 + 3 -> 9

- 14. cnt = 4, cnt = 5 < 5 (true)
- 15. i = 9, (i > 7) i = 9 - 4 -> 5;
- 16. i = 5, *(str + 5) -> F
- 17. i = 5 + 3 -> 8

- 18. cnt = 5, cnt = 6 (false)

-> BEHGF


16. 오류 예측 기법
- 1. 과거의 경험, 확인자의 감각으로 테스트, 
- 2. 찾아낼 수 없는 오류를 찾아내는 일련의 보충적 검사기법


17. 테스트 하네스
- 1. 테스트가 실행될 환경을 시뮬레이션
- 2. 컴포넌트 및 모듈이 정상적으로 테스트가 되도록 하는 테스트 자동화 도구


18. 

void func(int *a) {
  int x = 1;
  for (int i = 0; i >= 0; i += x) {
    *(a + i) += i;
   
    if (i >= 4) x = -1;
  }
}

main() {
  int arry[] = {1, 2, 3, 2, 1};
  func(arry);

  for (int i = 4; i >= 0; i--) printf("%d ", arry[i]);
}

- 1. arry = {1, 2, 3, 2, 1};
- 2. x = 1; for (int i = 0; i >= 0; i += x) i = 0
- 3. *(a + 0) = *(a + 0) + 0; -> 1  (1, 2, 3, 2, 1)

- 4. x = 1; for (int i = 0; i >= 0; i += x) i = 1
- 5. *(a + 1) = *(a + 1) + 1; -> 3  (1, 3, 3, 2, 1)

- 6. x = 1; for (int i = 0; i >= 0; i += x) i = 2
- 7. *(a + 2) = *(a + 2) + 2; -> 5  (1, 3, 5, 5, 5)

- 8. x = 1; for (int i = 0; i >= 0; i += x) i = 3
- 9. *(a + 3) = *(a + 3) + 3; -> 5  (1, 3, 5, 5, 5)

- 10. x = 1; for (int i = 0; i >= 0; i += x) i = 4
- 11. *(a + 4) = *(a + 4) + 4; -> 5;  (1, 3, 5, 5, 5)
- 12. if (i >-= 4) i = 4, x = -1;

- 13. x = -1; for (int i = 0; i >= 0; i += x) i = i + (-1) = 3
- 14. *(a + 3) = *(a + 3) + 3; -> 8;  (1, 3, 5, 8, 5)

- 15. x = 1; for (int i = 0; i >= 0; i += x) i = 2
- 16. *(a + 2) = *(a + 2) + 2; -> 7;  (1, 3, 7, 8, 5)

- 17. x = 1; for (int i = 0; i >= 0; i += x) i = 1
- 18. *(a + 1) = *(a + 1) + 1; -> 4;  (1, 4, 7, 8, 5)

- 19. x = 1; for (int i = 0; i >= 0; i += x) i = 0
- 20. *(a + 0) = *(a + 0) + 0; -> 1;  (1, 4, 7, 8, 5)

- 21. 5, 8, 7, 4, 1

--> 5, 8, 7, 4, 1
