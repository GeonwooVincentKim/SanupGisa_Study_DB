1. 복잡한 데이터 모델 (다차원 통합)
- 1. M : M 관계의 고리
  = 1. Example (사원, 직책, 회사)
     -> 1. 사람 (주민번호, 성명)
         => 1. 사람은 직책을 여러 개 가질 수 있음
         => 2. 사람은 회사를 여러 개 가질 수 있음 (Or 사람이 회사 여러 곳을 옮겨다니며 다녀본 적이 있을 수도 있음)

     -> 2. 직책 (직책코드, 직책명)
         => 1. 어떤 직책을 가지고 있는 사람이 한 사람이 아니라 여러 명일 수도 있음
         => 2. 어떤 직책을 가지고 있는 회사가 하나만 있는 것이 아닌 여러 개를 가지고 있을 수도 있음

     -> 3. 회사 (회사코드, 회사명)
         => 1. 회사에는 여러 명의 사람들 (사원들) 이 근무하고 있음
         => 2. 회사에는 여러 종류의 직책이 존재함

  = 2. Example (사원, 직책, 회사) 풀어내는 과정 (이력 관리)
     -> 1. 사람 (주민번호, 성명) & 직책 (직책코드, 직책명) 사이 Entity
         => 누가 언제 어떤 직책을 가지고 있었는지에 대한 이력 관리 가능
     
     -> 2. 사람 (주민번호, 성명) & 회사 (회사코드, 회사명) 사이 Entity
         => 어떤 사람이 언제 무슨 회사를 다녔는지에 대한 이력 관리 가능

     -> 3. 직책 (직책코드, 직책명) & 회사 (회사코드, 회사명) 사이 Entity
         => 그 회사가 조직이 어떻게 되어있었는지에 대한 이력 관리 가능

- 2. 3개 이상을 관리
  = 1. Example (그룹 이력, 사람, 회사, 직책)
     -> 1. 그룹이력 (업체명, 직책명)
     -> 2. 회사 (회사코드, 회사명)
     -> 3. 사람 (주민번호, 성명)
     -> 4. 직책(직책코드, 직책명)

  = 2. Example (그룹 이력, 사람, 회사, 직책) 그림으로 풀어내는 과정 (이력 관리)
     -> 1. 회사
         => 1.           ┌ B 회사 ->
              -- A 회사-┘

         => 2. A 회사에서 재직하였음
         => 3. B 회사에서 재직 중
         => 4. Source (회사)
    
     -> 2. 직책
         => 1. 
                                         ┌ 부장 ->
                               ┌ 과장 ┘
                       ┌대리┘
              --사원-┘

         => 2. 사원 -> 대리 -> 과장 -> 부장 순서로 진급하였음
         => 3. 회사가 바뀌든 안바뀌든 간에 직책이 바뀌는 것에 대해서만 관리하면 됨
         => 4. 임의의 시점에 어느 회사에서 어떤 직책이었는지에 대한 정보는 임의의 시점의 선분을 읽으면 알 수 있음
         => 5. Source (직책)

     -> 3. 그룹 이력
         => 1. 
                                                                            ┌ B사 부장 ->
                                                             ┌ B사 과장 ┘
                                             ┌ A사 과장 ┘
                              ┌ A사 대리 ┘
              -- A사 사원 -┘

         => 2. `회사` 와 `직책`을 통합하여 새로운 이력 관리 Entity 가 만들어짐
         => 3. A사 에서 사원 -> 대리 -> 과장을 역임함
         => 4. B사에서 과장을 역임하였고, 현재는 부장
         => 5. 임의의 시점에 놓여진 선분에서 어느 회사에서 어떤 직책이었는지에 관한 정보들을 Merge 하여 정리를 한 상태
         => 6. Merge (그룹 이력) = Source (회사) + Source (직책)
         => 7. Pre-Merge 가 되 있기 때문에, 선분 하나만 읽으면 원하는 데이터를 편하게 볼 수 있음 (장점)
         => 8. 어떤 데이터가 바뀐 시점에 일어난 특정 Event 을 찾으려고 할 때, 일일이 하나씩 앞 데이터부터 확인해 가며 찾아봐야 함
         => 9. 그룹 이력 Entity 에서 어떤 회사에 있었는지에 대해 정보를 찾으려고 하면 회사 Entity 에서 찾는 것보다 좀 더 시간이 많이 걸림

2. 이력 관리 (Github, GitLab 의 잔디 관리도 연관 되어 있음)
- 1. 이력 관리의 중요성
  = 1. 맨 마지막에 취급하는 이유
     -> 1. 이력 관리라는 개념을 넣는 순간에 모든 개념이 하나씩 바뀌어 버림
     -> 2. 데이터 모델링을 한 이유 => 본질적인 정보 (내가 무엇이고, 너는 무엇이고, 우리는 무엇인가에 대한 정보) 를 찾기 위해서 진행
     -> 3. 이력 관리를 어떻게 하는지에 따라 관리하는 Cost 가 들어가며 (또는 늘어날 수도 있음), 미래에 가서도 잘 다룰 수 있음

  = 2. 흘러가는 물과 막아두는 물 (댐)
     -> 1. 막아두는 물
         = 1. 필요한 물들만 댐을 막아서 저장해 둠
         = 2. 댐을 많이 세워두면 Cost 가 들어감

     -> 2. 흘러가는 물
         = 1. OLTP 의 Data
         = 2. 지금의 시각에선 쓰지 않을 물이라 생각하고 보내지만, 나중에 미래에 가서는 가공 데이터에 필요할 때, 흘러가는 물을 주워담을 수 있는지에 대한 여부

  = 3. 이력 관리를 함으로써, 미래에 필요한 데이터 유산들을 남길 수 있음
     -> Data Warehouse

- 2. 이력 관리 정의
  = 1. 이력을 관리하기 위해서는 이력을 관리하겠다는 관점에서 모델 전체를 새롭게 한 번 보고, Relation 추가 여부, Entity 추가 여부, Attribute 추가 여부 결정후 작업
  = 2. 어떤 부분을 이력을 관리할 것인지에 대한 전략적인 판단이 매우 중요
  = 3. 현재 뿐만 아니라 미래에 이 데이터의 활용 방안에 대해 미리 준비를 해 나갈 것인지에 대해 생각해보기
  = 4. 지나친 이력관리는 과도한 부담을 유발

- 3. 이력 관리 사용자 검증 사항
  = 1. 변경 내역을 우리가 나중에 어떻게 사용할 것인가
  = 2. 데이터가 변할 수 있는가
  = 3. Relation 이 변할 수 있는가
  = 4. 과거의 데이터를 어떻게 새로 쓸 것인가
  = 5. 버전 관리를 해야 하는가 (Or 어떻게 해야 하는가)

3. 이력 관리 시의 관계 변화
- 1. 지금까지 해놓은 모델에 Attribute 가 있을 때
  = 1. Attribute 가 1인 이유
     -> 1. Single Value 검증 통과
     -> 2. Normalize 에서 Post Normal 통과
     -> 3. 남아 있는 최종 집합은 1개 

  = 2. 1개에 이력을 관리 시작할 때
     -> 1. `+`, `알파`가 되어 M 이 됨
     -> 2. Post Normal 로 떨어져 새로운 Entity 로 추가 됨 (Association Entity)

- 2. M : M 이 되어 있는 상태에서 (이력 관리 Entity, Entity A, Entity B) 다시 이력을 추가할 경우
  = 1. M : M 이 됨
  = 2. M : M + 새로운 UID (식별자) 탄생
  = 3. 이력 관리를 하는 순간에 다시 새로운 이력 관리 Entity 가 탄생
  = 4. Example (계약 Entity) - 분리 전
     -> 1. 계약 Entity (계약 번호, 내역, 계약일, 계약 상태)
     -> 2. 각 `계약 건`에 대한 각각의 이력을 관리할 경우

  = 5. Example (계약 Entity) - 각 `계약 건`에 대한 `이력 관리 Entity` 생성
     -> 1. 계약 Entity (계약 번호, 내역)
         => 각 `계약 건` 에 대한 `이력 관리 Entity (계약 상태 Entity)` 를 불러 옴

     -> 2. 계약 상태 Entity (계약일, 계약 상태)
         => 각 `계약` 한 건 당 `계약 상태` 가 존재

- 3. RelationShip 의 주어 관리
  = 1. Example (아파트, 입주자) - 입주자 이력 관리 Entity  생성 전
     -> 1. 아파트 (번호, 주소)
     -> 2. 입주자 (주민 번호, 성명)

  = 2. Example (아파트, 입주자) - 입주자 이력 관리 Entity 생성 후
     -> 1. 아파트 (번호, 주소)
     -> 2. 입주 이력 (입주일, 퇴거일)
     -> 3. 입주자 (주민 번호, 성명)
  
  = 3. M : M 관계에서는 Entity 의 추가 없이 Relation Entity 를 이용 가능

4. 전통적인 이력 관리 방법
- 1. 이력 관리 커버 범위
  = Example (12초)
     -> 1. 12초 10 & 12초 99 & 12초 50 모두 12초라는 범위 안에 존재
     -> 2. 무한 대의 개수를 한 Column 에서 관리 가능

- 2. Event 발생할 때마다 생성 (괜찮은 방법)
  = Event 가 발생할 때마다 사진을 찍어 두어 이력을 관리 가능한가

- 3. Daily 마다 생성 (무식한 방법)
  = 1. 아무 변화가 없는 경우도 Data 생성
  = 2. 그러나 완벽한 이력 관리는 불가능

