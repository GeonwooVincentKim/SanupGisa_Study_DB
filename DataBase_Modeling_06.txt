1. Dependency 분류법
- 1. Key Entity 와 Main Entity 끄집어 내기
- 2. Key Entity 예시 구조 (난이도 = 분류코드)
  = 1. 고급 3개
  = 2. 중급 3개
  = 3. 초급 2개

- 3. Main Entity 예시 구조 (난이도 = 분류코드)
  = 1. 고급 2개
  = 2. 중급 2개 (고급과도 겹침)
  = 3. 초급 2개

- 4. Key Entity 와 Main Entity 끄집어 내기
  = 1. Main Entity 에서 초급이 3개일 경우 => Key Entity 의 값 그대로 가지고 옴
  = 2. Main Entity 에서 중급이 2개인데, 고급 2개하고도 값이 겹치는 경우 => Dependency 는 분류코드

2. 관계 (Relationship)
- 1. 관계의 정의
  = 1. 두 개의 ENTITY 가 그 자신과의 독립관계를 양방향으로 표현
  = 2. 현재의 관계나 장래 유용한 관계만 한정적으로 표시
  = 3. 각 방향의 관계
     -> 1. 관계 명칭 (부사형)
     -> 2. 선택 사양 (Optionality)
     -> 3. 관계 형태 (Degree) 를 표시
  
  = 4. 모든 Entity 는 단 하나씩 (하나 이상)의 Entity2 를 반드시 관계명(Relation Name) 해야 한다 (일 수도 있다)
     -> 1. 단 하나씩 (하나 이상) => 관계 형태
     -> 2. 관계명 (Relation Name) => 관계 명칭
     -> 3. 반드시 해야 한다 (일 수도 있다) => 선택 사양

  = 5. 관계명은 구체적 (`속하여`, `참조하여` 피하기)
  = 6. 주는 쪽 (One) -> 특정 집합만 관계 가질 시, 해당 집합 표현하는 것이 좋음
  = 7. 받는 쪽 (One or Many) -> 최대한 관계 내용을 구체적으로 표현
  = 8. 관계 분명 & 지극히 일반적인 경우 -> 관계명 생략 + 제3자의 관계로 표현해도 무방
  = 9. 보편 타당성 유지 (특별한 설명 없더라도 이해할 수 있는 일반적 & 객관적 용어 사용)

- 2. 수학적 귀납법
  = 1. 임의의 한 개를 가지고 와서 사실을 증명하고, 그 다음 것을 가지고 왔는데도 맞으면 전체가 다 사실을 증명한다는 사실 (수학적 귀납법)
  = 2. 임의의 나 & 각각의 나 & 모든 나 => `임의` 부터 `각각`, `모든` 전부 증명
  = 3. 사원과 부서의 관계 (N:1 관계)
     -> 1. 모두 사원은 부서를 가지고 있다. (비정규직 제외)
     -> 2. 사원은 부서를 가지고 있지 않을 수도 있다. (비정규직 포함)
     -> 3. (부모) ...___< (자식) => 자식은 태어난 이상 절대로 부모 없으면 안되는 관계 (점선 -> 수 틀리면)
     -> 4. (부모) ___...< (자식) => 부모는 자식을 만들지 않는 순간 사형당하는 관계
  
  = 4. 직선과 점선
     -> 1. 직선 
         => 1. (사원) >___ (부서) => 임의의 사원은 단 하나의 부서에 반드시 소속되어야 함
         => 3. (사원) |____ (부서) => 임의의 사원 한 명은 단 하나의 부서에 반드시 소속되어야 함
         => 4. (사원) |____ (부서) => 임의의 부서 한 곳은 단 하나의 사원을 
     
     -> 2. 점선
         => 1. (사원) >--- (부서) => 임의의 부서는 하나 이상의 사원을 안 가질 수도 있다.

     -> 3. 하나의 데이터 표시 => `|`
     -> 4. 여러 개 (N개) 데이터 표시 => `>-`

     -> 5. 직선 점선 혼용 (선택)
         [ (사원) >__...(부서) ]
         => 1. 임의의 사원은 단 하나의 부서에 소속되어야 함 (실선)
         => 2. 부서는 여러 명의 (하나 이상의) 사원을 가지지 않을 수도 있음 (점선)
